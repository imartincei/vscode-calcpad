#def genTableCSS$(headerBg$; rowBg$; cellBg$; borderColor$; padding$)
	#val
	'<style>
	'.calcpad-table { border-collapse: collapse; width: 100%; margin: 20px 0; }
	'.calcpad-table thead tr { background-color: headerBg$; }
	'.calcpad-table th, .calcpad-table td { border: 1px solid borderColor$; padding: padding$px; }
	'.calcpad-table th { text-align: center; font-weight: bold; }
	'.calcpad-table tbody td:first-child { font-weight: bold; background-color: rowBg$; }
	'.calcpad-table tbody td { text-align: center; background-color: cellBg$;}
	'</style>
	#equ
#end def
'
#def genTableStart$(id$; M$; header$; index$)
	#val
	'<script>
	'window.tableData = {
	'    matrix: 'M$',
	'    headers: header$,
	'    indices: index$
	'};
	'</script>
	'<div id="id$"></div>
	'<script>
	'function compareWithOperator(value, operatorSymbol, compareValue) {
	'    switch (operatorSymbol) {
	'        case "≡":
	'            return value === compareValue;
	'        case "≠":
	'            return value !== compareValue;
	'        case "≤":
	'            return value <= compareValue;
	'        case "≥":
	'            return value >= compareValue;
	'        default:
	'    }
	'}
	'(function() {
	'    const data = window.tableData;
	'    const matrix = data.matrix;
	'    const headers = data.headers;
	'    let indices = data.indices;
	'
	'    if (typeof indices === "string") {
	'        const baseText = indices;
	'        indices = [];
	'        for (let i = 0; i < matrix.length; i++) {
	'            indices.push(baseText + " " + (i + 1));
	'        }
	'    }
	'
	'    let html = "<table class=\"calcpad-table\">";
	'    html += "<thead><tr>";
	'    html += "<th></th>";
	'
	'    for (let col = 0; col < headers.length; col++) {
	'        html += "<th>" + headers[col] + "</th>";
	'    }
	'    html += "</tr></thead><tbody>";
	'
#end def
'
#def genTableEnd$(id$)
	'    html += "</tbody></table>";
	'    document.getElementById("id$").innerHTML = html;
	'})();
	'</script>
	#equ
#end def
#def genTable$(id$; M$; header$; index$; zeroBlack$)
	genTableStart$(id$; M$; header$; index$)
	'    for (let row = 0; row < indices.length; row++) {
	'        html += "<tr>";
	'        html += "<td>" + indices[row] + "</td>";
	'
	'        for (let col = 0; col < headers.length; col++) {
	'            const value = matrix[row][col];
	'            let bgColor;
	'            if ((zeroBlack$ && value === 0) || isNaN(value)) {
	'                bgColor = "black";
	'            }
	'            html += "<td style=\"background-color: " + bgColor + ";\">" + value + "</td>";
	'        }
	'        html += "</tr>";
	'    }
	genTableEnd$(id$)
#end def
'
#def genTableColor$(id$; M$; header$; index$; operator$; value$; passColor$; failColor$; zeroBlack$)
	genTableStart$(id$; M$; header$; index$)
	'    for (let row = 0; row < indices.length; row++) {
	'        html += "<tr>";
	'        html += "<td>" + indices[row] + "</td>";
	'
	'        for (let col = 0; col < headers.length; col++) {
	'            const value = matrix[row][col];
	'            let bgColor;
	'            if ((zeroBlack$ && value === 0) || isNaN(value)) {
	'                bgColor = "black";
	'            } else {
	'                bgColor = compareWithOperator(value, operator$, value$) ? "passColor$" : "failColor$";
	'            }
	'            html += "<td style=\"background-color: " + bgColor + ";\">" + value + "</td>";
	'        }
	'        html += "</tr>";
	'    }
	genTableEnd$(id$)
#end def
#local
M = [0; 2; 3|4; 5; 6|1; 4; 0/0]
genTableCSS$(#dfdfdf; #dfdfdf; #ffffff; #000000; 10)
'Use arrays of strings, e.g. ["Row 1", "Row 2"] or a string prefix, e.g. "Row" for the indecies'
genTable$(table1; M; ["Col 1", "Col 2", "Col 3"]; ["Row 1", "Row 2", "Row 3"]; true)
genTableColor$(table2; M; ["Col 1", "Col 2", "Col 3"]; "Row"; "≤"; 1; lime; pink; true)
